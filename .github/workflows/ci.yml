name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # 每天 UTC 02:00 (北京时间 10:00) 运行夜间测试
    - cron: '0 2 * * *'

env:
  GO_VERSION: '1.20'

jobs:
  # 代码质量检查
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run go fmt
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted properly:"
          gofmt -s -l .
          exit 1
        fi

    - name: Run go vet
      run: go vet ./...

    - name: Install golangci-lint
      run: |
        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2

    - name: Run golangci-lint
      run: $(go env GOPATH)/bin/golangci-lint run

  # 单元测试
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run unit tests
      run: |
        go test -v -race -coverprofile=coverage.out ./...
        go tool cover -func=coverage.out

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

  # SQLite 集成测试
  integration-sqlite:
    name: SQLite Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build SQLite test image
      run: |
        docker-compose -f docker-compose.sqlite.yml build --no-cache

    - name: Run SQLite integration tests
      run: |
        # 使用较短的测试时间以适应 CI 环境
        export TEST_DURATION=300s  # 5分钟测试
        export CONCURRENT_WORKERS=2
        export RECORDS_PER_WORKER=1000
        export BATCH_SIZE=100
        export BUFFER_SIZE=2000
        export FLUSH_INTERVAL=100ms
        
        # 运行测试并捕获退出码
        docker-compose -f docker-compose.sqlite.yml up --abort-on-container-exit --exit-code-from sqlite-test || true

    - name: Extract test reports
      run: |
        # 创建临时容器以提取报告
        docker create --name temp-sqlite batchsql-sqlite-test:latest
        docker cp temp-sqlite:/app/reports ./test/reports-sqlite || true
        docker rm temp-sqlite || true

    - name: Upload SQLite test reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: sqlite-test-reports
        path: test/reports-sqlite/
        retention-days: 30

  # MySQL 集成测试
  integration-mysql:
    name: MySQL Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: rootpass123
          MYSQL_DATABASE: batchsql_test
          MYSQL_USER: testuser
          MYSQL_PASSWORD: testpass123
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Wait for MySQL
      run: |
        for i in {30..0}; do
          if mysqladmin ping -h 127.0.0.1 -u testuser -ptestpass123 &> /dev/null; then
            break
          fi
          echo 'MySQL is unavailable - sleeping'
          sleep 2
        done

    - name: Build MySQL test image
      run: |
        docker-compose -f docker-compose.mysql.yml build --no-cache

    - name: Run MySQL integration tests
      run: |
        # 使用较短的测试时间以适应 CI 环境
        export TEST_DURATION=300s  # 5分钟测试
        export CONCURRENT_WORKERS=5
        export RECORDS_PER_WORKER=2000
        export BATCH_SIZE=200
        export BUFFER_SIZE=5000
        export FLUSH_INTERVAL=100ms
        
        # 更新 MySQL DSN 以连接到 GitHub Actions 的 MySQL 服务
        export MYSQL_DSN="testuser:testpass123@tcp(host.docker.internal:3306)/batchsql_test?parseTime=true&multiStatements=true"
        
        docker-compose -f docker-compose.mysql.yml up --abort-on-container-exit --exit-code-from mysql-test

    - name: Extract test reports
      run: |
        docker create --name temp-mysql batchsql-mysql-test:latest
        docker cp temp-mysql:/app/reports ./test/reports-mysql || true
        docker rm temp-mysql || true

    - name: Upload MySQL test reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: mysql-test-reports
        path: test/reports-mysql/
        retention-days: 30

  # PostgreSQL 集成测试
  integration-postgresql:
    name: PostgreSQL Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: batchsql_test
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass123
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build PostgreSQL test image
      run: |
        docker-compose -f docker-compose.postgres.yml build --no-cache

    - name: Run PostgreSQL integration tests
      run: |
        # 使用较短的测试时间以适应 CI 环境
        export TEST_DURATION=300s  # 5分钟测试
        export CONCURRENT_WORKERS=5
        export RECORDS_PER_WORKER=2000
        export BATCH_SIZE=200
        export BUFFER_SIZE=5000
        export FLUSH_INTERVAL=100ms
        
        # 更新 PostgreSQL DSN 以连接到 GitHub Actions 的 PostgreSQL 服务
        export POSTGRES_DSN="postgres://testuser:testpass123@host.docker.internal:5432/batchsql_test?sslmode=disable"
        
        docker-compose -f docker-compose.postgres.yml up --abort-on-container-exit --exit-code-from postgres-test

    - name: Extract test reports
      run: |
        docker create --name temp-postgres batchsql-postgres-test:latest
        docker cp temp-postgres:/app/reports ./test/reports-postgres || true
        docker rm temp-postgres || true

    - name: Upload PostgreSQL test reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: postgresql-test-reports
        path: test/reports-postgres/
        retention-days: 30

  # 性能基准测试（仅在主分支和定时任务中运行）
  performance-benchmarks:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    needs: [integration-sqlite, integration-mysql, integration-postgresql]
    if: github.ref == 'refs/heads/main' || github.event_name == 'schedule'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run Go benchmarks
      run: |
        go test -bench=. -benchmem -count=3 ./... > benchmark_results.txt

    - name: Upload benchmark results
      uses: actions/upload-artifact@v3
      with:
        name: benchmark-results
        path: benchmark_results.txt
        retention-days: 90

  # 生成测试报告汇总
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [integration-sqlite, integration-mysql, integration-postgresql]
    if: always()
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all test reports
      uses: actions/download-artifact@v3
      with:
        path: ./all-reports

    - name: Generate test summary
      run: |
        echo "# BatchSQL CI/CD Test Summary" > test_summary.md
        echo "" >> test_summary.md
        echo "## Test Results Overview" >> test_summary.md
        echo "" >> test_summary.md
        
        # 检查各个测试的状态
        if [ "${{ needs.integration-sqlite.result }}" == "success" ]; then
          echo "✅ SQLite Integration Tests: PASSED" >> test_summary.md
        else
          echo "❌ SQLite Integration Tests: FAILED (Expected - SQLite architectural limitations)" >> test_summary.md
        fi
        
        if [ "${{ needs.integration-mysql.result }}" == "success" ]; then
          echo "✅ MySQL Integration Tests: PASSED" >> test_summary.md
        else
          echo "❌ MySQL Integration Tests: FAILED" >> test_summary.md
        fi
        
        if [ "${{ needs.integration-postgresql.result }}" == "success" ]; then
          echo "✅ PostgreSQL Integration Tests: PASSED" >> test_summary.md
        else
          echo "❌ PostgreSQL Integration Tests: FAILED" >> test_summary.md
        fi
        
        echo "" >> test_summary.md
        echo "## Notes" >> test_summary.md
        echo "- SQLite test failures are expected due to architectural limitations" >> test_summary.md
        echo "- MySQL and PostgreSQL should pass all tests" >> test_summary.md
        echo "- Detailed reports are available in the artifacts" >> test_summary.md

    - name: Upload test summary
      uses: actions/upload-artifact@v3
      with:
        name: test-summary
        path: test_summary.md
        retention-days: 30

    - name: Comment PR with test results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('test_summary.md', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: summary
          });